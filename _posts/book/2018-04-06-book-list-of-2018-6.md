---
layout: post
title: 《Effective Java》
category: 读书
keywords: 阅读,书单,2018
---

## 第一章 引言
&emsp;&emsp;本书的目标：最有效的使用Java程序设计语言及基本类库。总共78个条目。

## 第一章 创建和销毁对象
#### 第1条：考虑用静态工厂方法代替构造器

优点：
1. 相比构造器，有自己的名称
2. 相比构造器，不必每次条用都创建一个新对象
3. 相比构造器，它们可以原返回类型的任何子类型的对象
4. 在创建参数化类型实例的时候，它们使代码变得更加简洁

缺点：
1. 类如果不含有公有的或者受保护的构造器，就不能被子类实例化
2. 它们与其他的静态方法实际上没有任何区别。

#### 第2条：遇到多个构造器参数时候要考虑用构建器
&emsp;&emsp;静态工厂和构造器有个共同的局限性：它们都不能很好地扩展到大量的可选参数。

多个构造器参数时候，可以用JavaBean模式，这个有很严重的缺点，因为构造过程被分配到几个调用中，在构造过程中JavaBean可能处于不一致的状态。类无法仅仅通过检验构造器参数的有效性来保证一致性。

Builder模式：与传统的重叠构造器模式相比，使用Builder模式的客户端代码将更加易于阅读和编写，构建器也比JavaBean更加安全。

#### 第3条：用私有构造器或者枚举类型强化Singleton属性
&emsp;&emsp;包含单个元素的枚举类型，在功能上与公有域方法相近，但是它更加简洁，无偿地提供了序列化机制，绝对防止多次实例化，即使在面对复杂的序列化或者反射攻击的时候。
#### 第4条：通过私有构造器强化不可实例化的能力
&emsp;&emsp;一些工具类不希望被实例化，实例化对它来说没有任何意义。可以显示制定private 构造器。这种习惯也有附作物，它使得一个类不能被子类化。因为所有的构造器都必须显式或者隐式地调用超类构造器，在这种情形下，子类就没有可访问的超类构造器可调用了。
#### 第5条：避免创建不必要的对象
&emsp;&emsp;重复创建的对象请static final（静态初始化期），只初始化一次，后面多次重复利用即可，再加上延迟化加载，完美！
&emsp;&emsp;要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。
&emsp;&emsp;通过维护自己的对象池（object pool）来避免创建对象并不是一种好的做法，除非池中的对象是非常重量级，真正正确使用对象池的典型对象实例就是数据库连接池。建立数据库连接的代价是非常昂贵的，因此重用这些对象非常有意义。
#### 第6条：消除过期的对象引用
&emsp;&emsp;一般而言，只要类自己管理内存，程序员就应该警惕内存泄漏问题。一旦元素被释放掉了，则该元素中包含的任何对象引用都应该被清空。
&emsp;&emsp;比如栈的过期引用就会可能导致程序的内存溢出。
#### 第7条：避免使用终结方法
&emsp;&emsp;终结方法（finalizer）通常是不可预测的，也是很危险的，一般情况下是不必要的。使用终结方法会导致行为不稳定、降低性能、以及可移植问题。
&emsp;&emsp;java语言规范不仅不保证终结方法被及时地执行，而且根本不保证它们会被执行。当一个程序终止的时候，某些已经无法访问的对象的终结方法却根本没有执行，这是有可能的。结论：不应该以来终结方法来更新重要的持久状态。例如，依赖终结方法来释放共享资源（比如数据库）上的永久锁，很容易让整个分布式系统垮掉。
&emsp;&emsp;如果类的对象中封装的资源（例如文件或者线程）确实需要终止，应该怎么做才能不用编写终结方法呢？只需提供一个显示的终止方法，并要求该类的客户端在每个实例不再有用的时候调用这个方法。显示的终止方法通常与try-finally结构结合起来使用，以确保及时终止。在finally子句内部调用显示的终止方法，可以保证即使在使用对象的时候有异常抛出，该终止方法也会执行。
&emsp;&emsp;如果使用了终结方法，就要记住调用super.finalize

## 第三章 对于所有对象都通用的方法

