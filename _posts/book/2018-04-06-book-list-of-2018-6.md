---
layout: post
title: 《Effective Java》
category: 读书
keywords: 阅读,书单,2018
---

## 第一章 引言
&emsp;&emsp;本书的目标：最有效的使用Java程序设计语言及基本类库。总共78个条目。

## 第一章 创建和销毁对象
#### 第1条：考虑用静态工厂方法代替构造器

优点：
1. 相比构造器，有自己的名称
2. 相比构造器，不必每次条用都创建一个新对象
3. 相比构造器，它们可以原返回类型的任何子类型的对象
4. 在创建参数化类型实例的时候，它们使代码变得更加简洁

缺点：
1. 类如果不含有公有的或者受保护的构造器，就不能被子类实例化
2. 它们与其他的静态方法实际上没有任何区别。

#### 第2条：遇到多个构造器参数时候要考虑用构建器
&emsp;&emsp;静态工厂和构造器有个共同的局限性：它们都不能很好地扩展到大量的可选参数。

多个构造器参数时候，可以用JavaBean模式，这个有很严重的缺点，因为构造过程被分配到几个调用中，在构造过程中JavaBean可能处于不一致的状态。类无法仅仅通过检验构造器参数的有效性来保证一致性。

Builder模式：与传统的重叠构造器模式相比，使用Builder模式的客户端代码将更加易于阅读和编写，构建器也比JavaBean更加安全。

#### 第3条：用私有构造器或者枚举类型强化Singleton属性
&emsp;&emsp;包含单个元素的枚举类型，在功能上与公有域方法相近，但是它更加简洁，无偿地提供了序列化机制，绝对防止多次实例化，即使在面对复杂的序列化或者反射攻击的时候。
#### 第4条：通过私有构造器强化不可实例化的能力
&emsp;&emsp;一些工具类不希望被实例化，实例化对它来说没有任何意义。可以显示制定private 构造器。这种习惯也有附作物，它使得一个类不能被子类化。因为所有的构造器都必须显式或者隐式地调用超类构造器，在这种情形下，子类就没有可访问的超类构造器可调用了。
#### 第5条：避免创建不必要的对象
&emsp;&emsp;重复创建的对象请static final（静态初始化期），只初始化一次，后面多次重复利用即可，再加上延迟化加载，完美！
&emsp;&emsp;要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。
&emsp;&emsp;通过维护自己的对象池（object pool）来避免创建对象并不是一种好的做法，除非池中的对象是非常重量级，真正正确使用对象池的典型对象实例就是数据库连接池。建立数据库连接的代价是非常昂贵的，因此重用这些对象非常有意义。
#### 第6条：消除过期的对象引用
&emsp;&emsp;一般而言，只要类自己管理内存，程序员就应该警惕内存泄漏问题。一旦元素被释放掉了，则该元素中包含的任何对象引用都应该被清空。
&emsp;&emsp;比如栈的过期引用就会可能导致程序的内存溢出。
#### 第7条：避免使用终结方法
&emsp;&emsp;终结方法（finalizer）通常是不可预测的，也是很危险的，一般情况下是不必要的。使用终结方法会导致行为不稳定、降低性能、以及可移植问题。
&emsp;&emsp;java语言规范不仅不保证终结方法被及时地执行，而且根本不保证它们会被执行。当一个程序终止的时候，某些已经无法访问的对象的终结方法却根本没有执行，这是有可能的。结论：不应该以来终结方法来更新重要的持久状态。例如，依赖终结方法来释放共享资源（比如数据库）上的永久锁，很容易让整个分布式系统垮掉。
&emsp;&emsp;如果类的对象中封装的资源（例如文件或者线程）确实需要终止，应该怎么做才能不用编写终结方法呢？只需提供一个显示的终止方法，并要求该类的客户端在每个实例不再有用的时候调用这个方法。显示的终止方法通常与try-finally结构结合起来使用，以确保及时终止。在finally子句内部调用显示的终止方法，可以保证即使在使用对象的时候有异常抛出，该终止方法也会执行。
&emsp;&emsp;如果使用了终结方法，就要记住调用super.finalize

## 第三章 对于所有对象都通用的方法
#### 第8条：覆盖equals时请遵循通用约定
&emsp;&emsp;最好不要去覆盖equals方法，如果需要覆盖请保证是对称性、传递性、一致性。
#### 第9条：覆盖equals时总要覆盖hashCode
&emsp;&emsp;如果不这样做，就会违反Object.hashCode的通用约定（相等的对象必须具有相等的散列码 hash code），从而导致该类无非结合所有的散列的集合一起正常的运作，这样的集合包括HashMap、HashSet和Hashtable。
&emsp;&emsp;一个好的散列函数通常倾向于“为不相等的对象产生不相等的散列码”。
#### 第10条：始终要覆盖toString
&emsp;&emsp;java.lang.Object提供的toString方法返回的是类的名称以及一个@符合。接着就是散列码的无符号十六进制表示法。
&emsp;&emsp;如果没有覆盖toString方法，产生的日志消息将难以理解。
#### 第11条：谨慎地覆盖clone
没看懂~~
#### 第12条：考虑实现Comparable接口

## 第四章 类和接口
#### 第13条：使类和成员的可访问性最小化
#### 第14条：在公有类中使用访问方法而非公有域
&emsp;&emsp;公有类永远都不应该暴露可变的域，应该用包含私有域和公有的访问方法（get set）的类来取代
#### 第15条：使可变性最小化
&emsp;&emsp;存在不可变的类有许多理由；不可变的类的类比可变类更加易于设计。
#### 第16条：复合优先于继承
&emsp;&emsp;继承是实现代码重用的有力手段，但他并非永远是完成这项工作的最佳工具。使用不当会导致软件变的很脆弱。在包的内部使用继承是非常安全的。在那里，子类和超类的实现都处在同一个程序员的控制之下。
&emsp;&emsp;简而言之，继承的功能非常强大的，但是也存在诸多的问题，因为它违背了封装的原则。只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。即便如此，如果子类和超类处在不同的包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性（fragility）。为了避免这种脆弱性，可以用复合和转发机制来代替继承，尤其当存在适当的接口可以实现包装类的时候。包装类不仅比子类更加健壮，而且功能也更加强大。
#### 第17条：要么为继承而设计，并提供文档说明，要么禁止继承
&emsp;&emsp;没怎么看懂。。。
#### 第18条：接口优于抽象类
#### 第19条：接口只用于定义类型
#### 第20条：类层次优先于标签类
&emsp;&emsp;类层次的另一个好处在于，它们可以用来反映类型之间本质上的层次关系，有助于增强灵活性，并进行更好的编译时类型检查。
#### 第20条：类层次优先于标签类
#### 第21条：用函数对象来表示策略
&emsp;&emsp;没怎么看懂。。。
#### 第22条：优先考虑静态成员类
嵌套类：
1. 静态成员类
2. 非静态成员类
3. 匿名类
4. 局部类  

&emsp;&emsp;除了第一种，后三种都成为内部类。匿名类不同于Java程序设计语言的其他任何语法单元。它没有名字，并不与其他的成员一起被生命，而是在使用的同时被声明和使用。



## 第7章 方法
#### 第38条：检查参数的有效性
&emsp;&emsp;编写方法时候，应当考虑它的参数有哪些限制。应该吧这些限制写到文档中，并且在这个方法体的开头处，通过显示的检查来实施这些限制。养成这样的习惯是非常重要的。因为只要有效性有一次失败，你为必要的有效性检查所付出的努力都可以连本地代利低得到偿还了。
#### 第39条：必要时进行保护性拷贝
&emsp;&emsp;如果类具有从客户端得到或者返回到客户端的可变组件，类就必须保护性地拷贝这些组件。
#### 第40条：谨慎设计方法签名
&emsp;&emsp;说了一些方法命名、参会个数/类型设计需要注意的小tips
#### 第42条：慎用重载
&emsp;&emsp;“能够重载方法”并不意味着就“应该重载方法”。一般情况下，对于多个具有相同参数数目你的方法来说，应该尽量避免重载方法。
#### 第43条：慎用可变参数
&emsp;&emsp;在重视性能的情况下，使用可变参数机制要特别小心。可变参数方法的每次调用都会导致进行一次数组分配和初始化。简而言之，再定义参数数目不定的方法时，可变参数是一种很方便的方式，但是它们不应该被过度滥用。如果使用不当，会产生混乱的结果。
#### 第44条：返回零长度的数组或者集合，而不是null
&emsp;&emsp;这样会导致必须有额外的代码来处理null返回值。
#### 第44条：为所有导出API元素编写文档注释



